# spring_boot_msa_study
스프링 부트로 개발하는 MSA 컴포넌트 책 공부

---

### 2025-09-16

#### 모놀리식 아키텍처와 마이크로서비스 아키텍처 (MSA)

1. 모놀리식 아키텍처
 - 애플리케이션이 하나의 큰 프로젝트로 구성됨
 - 모든 기능 (회원, 주문, 결제, 게시판... 등)이 하나의 배포 단위에 포함됨
 - 하나의 DB를 여러 기능이 공유함 (주문, 결제, 예약 등.. 여러 기능이 같은 DB를 사용)
 - 초기 단순하고 빠르게 개발 가능
 - 규모가 커지고 기능이 복잡해지면 관리가 힘들고 유지보수에 자원이 많이 들어감
 - 트래픽이 많아지고 부하가 커지면 애플리케이션 전체를 스케일아웃 해야함 -> 확장성 문제
 - 작은 프로젝트 / 빠른 개발에 유리

2. 마이크로서비스 아키텍처
 - 애플리케이션을 여러 개의 독립된 서비스로 쪼갬
 - 각 서비스는 독립 배포 가능, 기능마다 각각의 DB를 가짐
 - 서비스간 통신은 주로 REST API, 메시지큐 (Kafka 등) 사용
 - 장애 격리 (한 서비스 장애가 전체 시스템에 영향을 덜 줌 -> 예약 관련 서비스가 터져도 호텔정보 또는 항공정보 등을 열람 가능)
 - 모놀리식 아키텍처보다 설계가 훨씬 복잡함
 - 서비스마다 DB가 따로있어서 분산 트랜잭션 이슈 발생 가능성 큼
 - 대규모 프로젝트에 적합

---

### 2025-09-17

#### MSA 설계

마이크로서비스 아키텍처를 설계할 때 정해진 법칙이나 왕도는 없음  
다만 원칙과 체계가 있으면 명확한 기준이 생기고, 마이크로서비스를 다시 나누거나 합치는 일이 좀 더 수월할 것

전체 서비스 관점에서 봤을 때 어느 정도 크기로 마이크로서비스를 분리해야 하는지,  
너무 작게 혹은 너무 크게 분리하는 것은 아닌지,  
등의 고민을 덜어줄 원칙들 정리

 - 서비스 세분화 원칙  
   - 비즈니스 기능  
     비즈니스 기능으로 서비스 나누기  
     하나의 서비스가 여러 비즈니스 동작을 제공하면 서비스 복잡도 높아짐 -> 유지보수 어려워짐  
   - 성능  
     서비스 크기가 너무 커서 성능에 영향이 갈 정도면 나누는 것을 고려
   - 메시지 크기  
     성능과 연관 있는데, 통신하는 데이터 크기가 너무 크다면 나누는 것을 고려
   - 트랜잭션  
     트랜잭션으로 서비스 나누기
     

 - 도메인 주도 설계 (DDD)  
   DDD는 내용이 방대하다 도메인 모델간의 확연한 경계인 "바운디드 컨텍스트"를 기억하자


 -  단일 책임 원칙  
    하나의 클래스는 하나의 책임 -> 응집도 높고 결합도 낮음 (독립영역 -> 바운디드 컨텍스트)  
    객체지향원칙이 마이크로서비스에도 적용됨


 - 가벼운 통신 프로토콜  
   각 마이크로서비스 간의 가벼운 통신 (HTTP 기반의 REST-API를 많이 사용)  
   각 서비스 간의 통신의 부하 최소화


 - 외부 공개 인터페이스  
   서비스간의 통신이 필연적이기 때문에 한번 공개된 마이크로서비스의 메시지 포맷(응답값 구조화)을 바꾸기 힘듬 -> 버전 변경 같은 방법으로 점진적으로 인터페이스를 변경함 

   
 - 마이크로서비스마다 독립된 데이터 저장소  
   단일 책임 원칙 응용 -> 각 서비스의 독립성 높임
   
마이크로서비스의 궁극적인 목적은 서비스 전체 기능을 빠르게 개발, 확장하기 위함  
각 서비스 의존성은 줄이고, 독립성을 보장해야 함

---

### 2025-09-18

#### 고가용성을 위한 확장

하나의 WAS, 하나의 DB로 시작한 서비스가 점점 사용자가 많아져 사용량이 늘어나면서 트래픽 부하로 시스템 장애가 생길 수 있다

WAS 확장  
서비스 안정성을 위하여 서버 이중화 혹은 다중화(확장, scale out)를 통해 고가용성을 확보하는 것이 중요하다
고가용성을 확보하는 방법은 여러가지가 있겠지만 일반적으로 로드 밸런서를 사용한다  
로드 밸런서가 사용자 요청을 모두 받고 서버로 사용자 요청을 분산한다 (이론상 로드 밸런서의 처리 한계까지 성능이 증가)  
또한 웹서버를 둬서 정적 리소스나 HTTPS 인증서 처리 등의 일들은 로드 밸런서가 웹서버로 보내 WAS의 부담을 덜어준다 

DB 확장  
DB는 WAS와 같이 스케일아웃 하기 힘들다  
하지만 DB도 고가용성을 확보할 수 있는 방법이 있는데, MySQL은 가장 많이 사용하는 방법이 MMM(Multi-Master Replication Manager for MySQL)이다  
간략하게 말하면 Master가 있고, Slave가 있는데 한개의 마스터로 여러개의 슬레이브를 만들고(복제) 마스터 DB의 데이터가 수정되면 해당 데이터들은 클러스터 내 여러 슬레이브로 전달되어 결국 모두 똑같은 데이터를 저장하게 된다  
여기서 마스터에서 슬레이브로 데이터를 전파하는 것을 리플리케이션(Replication)이라고 한다

또한 DB 샤딩 기법을 사용할 수 있는데,  
간단히 말해서 데이터들을 샤드라는 단위로 여러 데이터베이스 인스턴스에 나눠서 관리하는 기법이다  
100개의 데이터가 있으면, 5개의 샤드로 각 20개씩 나눠 관리하게 하며,  
WAS에 요청을 분산해줬던 로드 밸런서와 비슷하게 각 샤드의 위치를 알고, 관리하며 저장 및 조회를 돕는 일종의 애플리케이션인 로케이션 서비스가 있다  
샤딩 기법을 사용하면 확장성, 가용성이 좋아지며 성능이 향상 되지만, 운영 및 관리가 그만큼 복잡하기에 설계를 잘 하고 또 잘 알고 사용해야 한다

--- 

### 2025-09-20

#### 12 요소 애플리케이션  

클라우드 컴퓨팅 환경에 적합한 유연한 애플리케이션을 개발하는 방법론

#### 1. 코드베이스: 버전 관리되는 하나의 코드베이스와 다양한 배포  
    코드 버전관리 (git, svn)


#### 2. 의존성: 명시적으로 선언할 수 있고 분리할 수 있는 의존성  
      의존성 관리 도구(maven, gradle ..) 사용으로 의존성 관리에 자유로울 수 있음


#### 3. 설정: 환경 변수를 이용한 설정  
      외부 요인으로 변할 수 있는 값들은 환경변수를 이용하여 처리 (vm 옵션 -D"환경변수이름"="환경변수값") 


#### 4. 지원 서비스: 지원 서비스는 연결된 리소스로 처리  
      JDBC로 연결된 DB 저장소나 결제 시스템 같은 다른 도메인 영역을 담당하는 마이크로서비스들을 지원 서비스라고 함  
      네트워크를 통해 연결, 분리 -> 느슨한 결합


#### 5. 빌드, 릴리즈, 실행: 소스 빌드와 실행은 완전히 분리되어야 한다  
      빌드 - 의존성이 잇는 라이브러리들과 코드베이스를 조합하여 컴파일 (메이븐의 컴파일)  
      릴리즈 - 스프링 프로파일 혹은 메이븐 프로파일 설정을 이용하여 resources에 위치한 설정 파일들 조합 -> jar 파일 생성 (메이븐의 패키지)  
      실행 - 앞서 생성된 실행 가능한 jar 파일을 java 명령어로 실행


#### 6. 프로세스: 애플리케이션은 하나 이상의 무상태 프로세스로 실행되어야 한다  
      각 프로세스는 이전 요청의 상태(세션, 캐시, 파일 등)에 의존하지 않아야 한다  
      로드밸런서의 요청 분산 방식을 라운드 로빈 방식을 권장, 어떤 프로세스에 요청이 가든 결과가 동일해야 한다 (무상태 프로세스)
      상태는 외부 리소스 (DB, Redis, Memcached..) 에 저장  
      무상태 설계 -> 세션 거의 안씀  


#### 7. 포트 바인딩: 포트 바인딩을 통한 서비스 공개  
      스스로 웹서버 기능을 내장하고, 네트워크 포트를 열어 서비스 제공  
      즉, 앱이 독립 실행형으로 실행 가능해야 한다  
      다른 서비스가 붙을 때 특정 중간 계층(Apache, Nginx ..)을 거칠 필요 없도록  


#### 8. 동시성: 프로세스들을 통한 수평 확장  
      애플리케이션을 하나의 큰 프로세스로 돌리지 말고, 작은 여러 프로세스로 쪼개서 동시에 실행해야 한다는 원칙  
      즉, Scale Up(한 서버에 CPU, 메모리 늘리기) 보다는 Scale Out(프로세스/인스턴스 개수 늘리기)이 기본 전략


#### 9. 폐기 가능: 프로세스는 빠르게 시작해야 하고 안정적으로 종료해야 한다  
    빠른 시작(Fast startup) - 애플리케이션은 가능한 빨리 시작할 수 있어야 한다 -> 배포 속도, 장애 복구 속도, 자동 스케일링 대응  
    정상 종료(Graceful shutdown) - 프로세스가 종료될 때는 작업중인 요청이나 메시지를 안전하게 마무리해야 한다  
    프로세스가 종료될 때 지원 서비스 등의 자원 종료 (Ftp, Connection 등 반환 - close()) 


#### 10. Dev 환경과 Production 환경 일치  
      Dev 환경과 실제 Production 환경을 가능한 비슷하게 설정하고 유지해야 한다  
      그렇지 않으면 QA 결과가 다를 수 있음 


#### 11. 로그: 로그는 이벤트 스트림으로 다룬다  
      애플리케이션은 로그를 파일로 직접 관리하지 않아야 한다  
      로그는 그 자체로 단순한 이벤트 스트림일 뿐이고, 수집/보관/분석은 외부 시스템의 역할이다  
       - 무상태 원칙 유지 (로그 파일을 로컬 디스크에 쓰면 컨테이너/인스턴스 삭제 시 로그도 사라짐)
       - 확장성과 유연성 (로그는 외부 중앙 시스템 [예: ELK stack, Splunk 등])에서 수집/분석 해야함  
         앱은 그저 로그를 흘려보내기만 하면 됨
    

#### 12. 관리(admin) 프로세스: 시스템 유지 보수를 위한 일회성 프로세스  
      운영/관리 작업을 상시 프로세스에 넣지 말고, 일회성 프로세스로 실행하라는 원칙  
      DB 마이그레이션 같은 작업을 앱과 동일한 코드/환경에서 실행하되 독립 실행 가능하도록 설계

---

### 2025-09-22

#### 스프링(프레임워크/부트) 선택 이유와 장점

 - 확장성: 대규모 모놀리식부터 MSA까지 확장 가능


 - 검증된 안정성: 다년간의 사용으로 품질과 안정성이 입증됨


 - 방대한 커뮤니티와 자료: 문제 발생 시 해결책을 찾기 쉬움


 - 다양한 모듈: AOP, MVC, Messaging 등 필요한 기능을 모듈 단위로 선택적으로 사용 가능


 -  빠른 개발 속도: 설정을 최소화하고, 의존성 관리 자동화


 - 독립 실행형 애플리케이션: 별도 WAS 설치 없이 내장 서버(Tomcat, Jetty 등)로 실행 가능


 - 클라우드/컨테이너 환경 친화적: Docker, Kubernetes 등과 잘 맞음 → MSA 구성에 최적화


 - DevOps 친화성: 프로파일 기반 설정, actuator(운영 모니터링), 헬스 체크 지원


 - 관례 중심 설정(Convention over Configuration): 기본값 제공 → 개발자는 핵심 비즈니스 로직에 집중 가능


 - 스타터 의존성: spring-boot-starter-* 로 필요한 기능(웹, JPA, 시큐리티 등)을 손쉽게 추가


 - 운영/모니터링 편의성: Actuator를 통한 상태 확인, 로그, 메트릭 노출


 - 테스트 용이성: 내장 DB(H2)나 Mock 환경을 쉽게 설정 가능


 - 경량 배포: Jar 파일 하나로 패키징 → 마이크로서비스 배포에 적합

스프링의 장점을 설명할 때 EJB (Enterprise JavaBeans) 가 비교대상으로 자주 등장하는데,  
EJB는 프레임워크 코드가 개발자의 코드에 복잡하게 얽히는 반면 스프링은 프레임워크 로직과 비즈니스 로직이 확실히 분리되는 비침투적 프레임워크이다

---

### 2025-09-23

#### chapter02 프로젝트 생성

#### @SpringBootApplication  
스프링 부트 프로젝트 생성 시 main() 메소드 (entry point) 에 @SpringBootApplication이 선언되어 있는데,  
이 어노테이션 내부에는 아래의 핵심 어노테이션이 있다

 - @SpringBootConfiguration  
    자바 설정 클래스로 별도의 스프링 빈을 정의할 수 있음
    

 - @EnableAutoConfiguration  
    스프링 부트 프레임워크의 자동 설정 기능을 활성화하는 기능 제공  
   (META-INF 폴더의 spring.factories에 정의된 데이터를 읽는 SpringFactoriesLoader가 포함되어 있음)

   
 - @ComponentScan  
    자바 설정 클래스와 스테레오 타입 (@Controller, @Service, @Repository, @Component..) 어노테이션으로 정의된 클래스 스캔  
   
자바 설정 클래스와 스프링 빈 클래스를 스캔하여 스프링 컨테이너에 등록하고 스프링 부트의 자동 설정 기능 동작 등 ..   
스프링 프레임워크라면 개발자가 이런 과정을 직접 설정해줘야 하는데, 스프링 부트에서는 @SpringBootAppliction 어노테이션 하나로 간단하게 이런 복잡한 설정들을 처리할 수 있다

#### SpringApplication.run()

SpringApplication의 run() 메소드에서는  
스프링 빈을 로딩하고 이를 관리하는 ApplicationContext (스프링 컨테이너) 객체를 생성한다  
또한 지연 초기화 (lazy initialization) 기능을 제공하여 실행 시 스프링 빈을 전체 초기화 하지 않고 스프링 빈 객체가 사용될 때 초기화 할 수 있다  

(스프링 프레임워크 공부할 때 하나하나 설정했던 내용들인데 부트는 이렇게 설정이 간단함)

--- 

### 2025-09-25

#### Spring Bean

스프링에서는 객체를 직접 생성하지 않고 스프링 빈으로 등록해 컨테이너가 관리하게 한다(IOC)  
그 결과, 객체 간 의존성을 DI로 주입할 수 있고, 결합도가 낮아진다

스프링 빈을 정의할 수 있는 방법
- 자바 설정 클래스에서 @Bean 어노테이션을 사용하여 정의
- 스테레오 타입 어노테이션을 사용하여 정의
- BeanDefinition 인터페이스를 구현하여 정의
- XML 설정 방식을 사용하여 정의

스프링 빈을 정의 하는 방법은 다양하고 스프링 빈 컨테이너 구현체(ApplicationContext)에 따라 결정된다

---

### 2025-09-26

#### 자바 설정

Spring boot 설정 어노테이션  

 - @Configuration  
    자바 설정 클래스를 정의하는 데 사용한다  
    클래스 선언부에 정의하면 스프링 빈 컨테이너가 이 어노테이션으로 설정된 클래스들을 메타 정보로 간주하고 로딩한다  
    @Bean으로 선언된 메서드들을 포함할 수 있고 이를 로딩한 스프링 빈 컨테이너에 의해 스프링 빈으로 생성된다
   
   
 - @ComponentScan  
    @ComponentScan([설정]) -> [설정]에 설정된 패키지 경로에 포함된 자바 설정 클래스들과 스테레오 타입 어노테이션들이 선언된 클래스들을 스캔한다  
    [설정]에 아무것도 설정하지 않으면 @ComponentScan이 정의된 클래스가 위치한 패키지가 기본값이 되며 하위 패키지들에 포함된 모든 클래스를 스캔한다  
    (스캔하여 빈 등록함)
    스프링 어플리케이션을 설정하는 어노테이션이기 때문에 @Configuration 어노테이션과 함께 사용해야 동작한다


 - @Import  
    @ComponentScan과 역할이 비슷하지만 @Import는 정확한 클래스명을 명시한다 (잘 안쓰임)

---

### 2025-09-28

#### 주요 스테레오 타입 어노테이션

 - @Component  
    가장 일반적인 스테레오타입  
    스프링이 자동으로 빈으로 등록하도록 표시하는 가장 기본적인 어노테이션


 - @Controller  
    프레젠테이션 계층(Web MVC의 컨트롤러)에서 사용  
    주로 HTTP 요청을 받아서 처리하는 역할  
    Spring MVC에서 이 어노테이션을 붙이면 요청 매핑(@RequestMapping 등) 기능이 활성화됨

 
- @Service  
  비즈니스 로직(서비스 계층)을 담당하는 클래스에 사용  
    특별한 기능은 없고, @Component와 동일하지만 **“여기는 서비스 계층이야”**라고 개발자와 툴(Spring AOP 등)에게 알려주는 의미  
    AOP 적용 시(예: 트랜잭션) 관점에 따라 자동으로 처리되기도 함  


 - @Repository  
    데이터 접근 계층(DAO, Repository)에 사용  
    @Component의 특수화된 버전  
    특징: 스프링이 데이터 접근 계층의 예외를 스프링 예외 계층(DataAccessException)으로 변환해줌

---

### 2025-09-29

#### 스테레오 타입 어노테이션 실습  

Formatter 인터페이스와 LocalDateTimeFormatter 구현체를 만들어 @Component 어노테이션 실습  

SpringBean02Application(@SpringBootApplicaiton)에서 스프링 빈 컨테이너를 실행시키면  
LocalDateTiemFormatter 클래스가 스캔됨  

예제에서 사용된 ApplicationContext(context)의 getBean()의 인수에 부모 클래스인 Formatter.class를 사용해도 됨  

만약 다른사람이 또 LocalDateTiemFormatter를 다른 패키지에 Bean 등록하여 이름이 겹친다면 예외 발생함  
그럴 땐 @Component의 (value)로 이름을 바꾸거나 중복된 기능이면 하나로 합쳐주자

---

### 2025-09-30

#### 의존성 주입 (DI) 실습

오늘 실습 한 NotificationService에서 Sender를 인터페이스로 만들어 구현체를 외부에서 주입받지 않고  
NotificationService 내부에서 AppPushSender나 SmsSender를 직접 생성해 필드를 set하고 사용했다고 생각해보자  
AppPushSender나 SmsSender (하위모듈)가 수정되면 NotificationService (상위모듈)도 수정해줘야 한다  
이는 강한 결합도를 가지고 있고 코드가 많아진다면 유지보수 하기 힘들 것이다
이처럼, 의존성 주입은 결합도를 낮추고 응집도를 올려준다


1. 어노테이션 기반 DI
 - @Autowired : 타입(Type) 기반 주입
 - @Qualifier : 같은 타입의 빈이 여러 개일 때 특정 이름으로 구분

2. 자바 설정 기반 DI
 - @Configuration : 설정 클래스 선언
 - @Bean : 메서드 반환값을 스프링 빈으로 등록

---

### 2025-10-02

#### 스프링 빈 스코프 (멀티 쓰레드 실습)

스프링 빈 스코프는 기본값이 singleton인데, prototype과 request, session, application 등이 있다  
(스프링프레임워크 책 배울 때 했던 내용이라 설명은 패스)  

오늘은 멀티 쓰레드에서 안전하지 않은 객체를 singleton으로 주입했을 때 어떤 문제가 발생하는지 실습 해봤다  

우선 DateFormatter를 Bean 등록하는데, DateFormatter는 필드로 SimpleDateFormat를 가지고 있다  
여기서 SimpleDateFormat이 문제인데, 이유는 이 SimpleDateFormat은 parse()나 format() 같은 메서드가 내부적으로 상태를 가진 객체를 사용하기 때문에 멀티쓰레드에 안전하지 않기 때문이다  
그래서 멀티 쓰레드로 테스트 시 오류가 발생한다 (SpringBean05Application에서 쓰레드 100개로 테스트)  

즉 멀티쓰레드 안전하지 않은 객체는 빈 등록 전에 스코프를 고민해봐야 한다  
위 오류는 Bean의 스코프를 prototype으로 바꿔 해결했다  
싱글톤이라고 다 좋은게 아니라는걸 명심해야겠다

---

### 2025-10-04

#### 스프링 빈 생명주기 관리

스프링 빈의 생명주기 (생성, 소멸) 과정에서 개발자가 콜백 함수를 만들어두어 특정 시점(초기화/소멸)에 호출하게 할 수 있다  

주로 리소스 초기화, 리소스 정리, 주입 완료 후 후처리, 라이브러리/외부 API 연동 에 사용한다  

 - 리소스 초기화  
    DB Connection Pool 초기화  
    캐시 로딩  
    소켓 연결  
    -> @PostConstruct 또는 InitializingBean.afterPropertiesSet() 같은 메서드에 구현


 - 리소스 정리 (소멸 콜백)  
    네트워크 연결 닫기  
    쓰레드풀 shutdown  
    파일/로그 flush      
    -> @PreDestroy 또는 DisposableBean.destroy() 같은 메서드에 구현


 - 의존관계 주입 완료 후 후처리     
    어떤 빈이 다른 빈을 주입받은 뒤, 그 빈을 활용해서 초기 데이터를 세팅해야 할 때  
    예: UserRepository 주입 후, 메모리에 사용자 캐시 로딩  
    생성자에서는 아직 주입이 끝나지 않았을 수 있으므로, 모든 주입이 끝난 후 호출되는 초기화 콜백에 넣음


 - 라이브러리/외부 API 연동  
   외부 API SDK 같은 걸 사용할 때, 스프링 컨테이너가 빈을 생성해주면  
   API 초기화 코드를 콜백에 넣어두어 스프링이 알아서 호출하게 함  
   (-> 빈을 직접 new 해서 관리하지 않고 스프링 컨테이너에 맡길 수 있음)    


정리하자면 스프링 빈 생명주기 콜백은 주로 어플리케이션 전반에 걸쳐 계속 유지되는 리소스에 적합하다  
특정 서비스 메서드에서 잠깐 쓰고 닫는 경우 즉, 요청 단위로만 필요한 리소스는 생명주기 콜백 보다는 메서드 내에서 직접 열고 닫는 방식이 적절하다

---

### 2025-10-12

#### 스프링 빈 고급 정의 (@Primary, @Lazy)

 - @Primary  
    클래스 타입이 같은 여러 스프링 빈이 컨테이너에 있을 때,  
    기존 주입 방법으로 의존성 주입을 시도하면 컨테이너는 어떤 스프링 빈을 주입해야 하는지 알 수 없어 오류가 발생한다  
    이전 예제에선 위를 해결하기 위해 주입 받는 곳에서 @Qualifier 어노테이션을 사용하여 특정 빈의 이름을 지정해줬었는데,  
    스프링 빈을 선언할 때 @Primary 어노테이션을 사용하면 해당 빈을 같은 타입을 가진 빈 중 기본 빈으로 설정할 수 있다  


 - @Lazy  
    스프링 빈은 컨테이너가 빌드될 때 빈 설정 및 객체 인스턴스가 생성되는데 (컨테이너가 @Bean이 명시된 메소드 호출 -> 객체 반환/생성),  
    @Lazy 어노테이션이 선언된 스프링 빈은 컨테이너가 빌드될 때 빈 설정만 해두고 해당 빈이 사용될 때 생성한다      

---

### 2025-10-15

#### REST-API의 특성과 설계

 - 무상태성  
    서버가 클라이언트의 이전 요청 정보를 기억하지 않음  
    -> 요청마다 필요한 정보를 전부 담아서 보냄  
    -> 서버 확장 쉬움 / 장애 시 다른 서버로 쉽게 분산 가능  
    예: 로그인 세션 대신 토큰(JWT)을 요청에 포함


 - 일관성  
    API 설계 규칙이 일관되게 유지되어야 함  
    -> 같은 규칙, 같은 방식으로 요청·응답  
   (응답 메시지를 일관되게 만들고, 요청 uri 또한 규칙을 정함)
    -> 사용자가 예측하기 쉽고 유지보수 편리  
    예: /users는 항상 사용자 관련, /products는 상품 관련


 - 멱등성  
    같은 요청을 여러 번 보내도 결과가 같음  
    POST만 예외적으로 비멱등 (새로운 데이터 생성)  
    GET, PUT, DELETE 등 요청을 여러번 보내도 결과가 같도록 설계 해야 함

---

### 2025-10-16

#### @ResponseBody와 HttpMessageConverter

HttpMessageConverter의 역할  
HTTP 요청(Request) 본문 -> 자바 객체로 변환 (deserialize)  
자바 객체 -> HTTP 응답(Response) 본문으로 변환 (serialize)

Spring MVC는 RequestMappingHandlerAdapter 내부에 여러 개의 HttpMessageConverter를 등록해 두고,  
요청과 응답의 Content-Type, Accept 헤더를 기준으로 적절한 변환기를 자동으로 선택한다  

일반적으로 컨트롤러는 View 이름을 반환하지만, @ResponseBody를 명시하면 ViewResolver를 거치지 않고 리턴값을 HTTP Response Body에 직접 쓴다  
이 때 Spring MVC는 요청의 Content-Type(요청 본문 형식)과 응답의 Accept(응답 희망 형식) 헤더를 기준으로, 적절한 HttpMessageConverter를 선택하여 데이터를 변환한다

---

### 2025-10-21

#### Jackson 라이브러리의 @JsonProperty, @JsonSerializer, @JsonFormat

먼저 위 세 어노테이션은  
REST-API에서 주고받는 JSON 메시지를 만들 때(마셜링/언마셜링) 사용된다 

마셜링: 객체 -> JSON 변환

 - @JsonProperty  
    이 어노테이션을 명시한 컬럼은 JSON으로 마셜링 될 때 컬럼명이 아닌 어노테이션에 지정한 필드 이름으로 변경된다  
    시스템에서 사용하는 속성 이름과 JSON 객체에서 사용해야 할 속성 이름이 다른 경우 이 어노테이션 설정으로 간단하게 응답값 변경 가능  
    예를 들어 hotelRoomdId 속성을 가진 객체인데, JSON 응답값을 id로 반환해야 하는 경우  
    hotelRoomdId 속성에 @JsonProperty("id") 선언
   
 
 - @JsonSerializer  
    단순 변환 이상의 맞춤형 JSON 변환이 필요할 때 사용 된다  
    예를들어 서버에서 클라이언트로 Long 타입의 데이터를 보낼 때,  
    js에서는 64비트 정수를 안전하게 표현하지 못하기 때문에 Long 타입은 보통 String으로 변환하여 보내주는게 좋은데,  
    이럴 때 @JsonSerializer("using = ToStringSerializer.class") 와 같이 선언해준다  
    ToStringSerializer는 Jackson에서 제공하며 여러가지 JsonSerializer 구현체가 있고, 커스텀 해서 쓸 수도 있다  
   
   
 - @JsonFormat  
    날짜/시간, 숫자, 문자열 등 필드 포맷을 지정할 때 사용하는 어노테이션  
    커스텀 Serializer를 만들지 않아도, 간단한 포맷 변경이 가능 하며  
    주로 날짜/시간(Date, LocalDate, LocalDateTime), Enum, 숫자 등에서 사용한다  
    예:   
    @JsonFormat(pattern = "yyyy-MM-dd")  
    private LocalDate birthDate;



--- 